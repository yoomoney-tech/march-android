import groovy.json.JsonSlurper

ext {

    minSdkVersion = 19
    targetSdkVersion = 28
    compileSdkVersion = 28

    coroutines_version = '1.3.5'
    mockitoKotlin = '2.2.0'
    lifecycle = '2.2.0'

    final PARTS_VERSION_TOTAL_COUNT = 3
    final PARTS_VERSION_POSITION_MAJOR = 0
    final PARTS_VERSION_POSITION_MINOR = 1
    final PARTS_VERSION_POSITION_PATCH = 2

    File versionFile = file("package.json")
    List<Integer> versionParts
    if (versionFile.exists()) {
        def parser = new JsonSlurper()
        def jsonResp = parser.parseText(versionFile.text)
        if(jsonResp.version != null){
            versionParts = jsonResp.version.split("\\.").collect { partVersion ->
                String errorNumberFormatMessage = "Parts of version must be number"
                try {
                    Integer.parseInt(partVersion)
                } catch (NumberFormatException ex) {
                    throw ex(errorNumberFormatMessage)
                }
            }
        }
        if (versionParts.size() < PARTS_VERSION_TOTAL_COUNT)
            throw new IllegalStateException("package.json file must contains field version  at least major.minor.patch" +
                    "e.g. \"version\": \"1.0.2\"")
    } else throw new IllegalStateException(
            "Can't find package.json file.\nCreate package.json file in root of project " +
                    "and write app version in the format major.minor.patch.alpha (e.g. \"version\": \"1.0.2\").\n"
    )

    versionMajor = versionParts[PARTS_VERSION_POSITION_MAJOR]
    versionMinor = versionParts[PARTS_VERSION_POSITION_MINOR]
    versionPatch = versionParts[PARTS_VERSION_POSITION_PATCH]

    getAppVersionCode = { versionMajor * 1000000 + versionMinor * 10000 + versionPatch }

    getAppVersionName = {
        "$versionMajor.$versionMinor.$versionPatch"
    }

    zipReleaseName = {
        "march-${getAppVersionName()}-${getTeamcityBuildconfName()}-${getBuildNumber()}-${getGitHash()}"
    }
}